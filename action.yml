name: 'Nx Migrate Action'
description: 'Automatically migrate Nx workspace to the latest version and create PRs for review and validation.'
author: 'Khalil LAGRIDA'

branding:
  icon: 'arrow-up'
  color: 'blue'

inputs:
  nx-package:
    description: 'The Nx package to check for updates'
    required: false
    default: 'nx'

  package-manager:
    description: 'Package manager to use (npm, yarn, pnpm)'
    required: false
    default: 'npm'

  pr-labels:
    description: 'Labels to add to PRs (comma-separated)'
    required: false
    default: 'nx-migrate-action'

  commit-message-prefix:
    description: 'Prefix for commit messages'
    required: false
    default: 'build'

  working-directory:
    description: 'Working directory for the action'
    required: false
    default: '.'

  push-migrations-json:
    description: 'Push migrations.json to repository after successful migration'
    required: false
    default: 'false'

  nx-version:
    description: 'Version to use when fetching updates (latest, next, or specific version like 19.8.0)'
    required: false
    default: 'latest'

  create-missing-labels:
    description: 'Create missing labels in the repository'
    required: false
    default: 'true'

  skip-initial-install:
    description: 'Skip initial dependency installation (useful if dependencies are already installed)'
    required: false
    default: 'false'

  dev-mode:
    description: 'Enable dev mode for testing (creates unique branches with matrix info)'
    required: false
    default: 'false'

outputs:
  updated:
    description: 'Whether Nx was updated'
    value: ${{ steps.check-update.outputs.updated }}

  current-version:
    description: 'Current Nx version before update'
    value: ${{ steps.check-update.outputs.current-version }}

  target-version:
    description: 'Target Nx version for migration'
    value: ${{ steps.check-update.outputs.target-version }}

  has-migrations:
    description: 'Whether migrations were found'
    value: ${{ steps.check-migrations.outputs.has-migrations }}

  pr-url:
    description: 'URL of created PR (if any)'
    value: ${{ steps.create-pr.outputs.pr-url }}

runs:
  using: 'composite'
  steps:
    - name: Install dependencies
      if: inputs.skip-initial-install != 'true'
      shell: bash
      working-directory: ${{ inputs.working-directory }}
      run: |
        case "${{ inputs.package-manager }}" in
          npm)
            npm ci
            ;;
          yarn)
            yarn install --frozen-lockfile
            ;;
          pnpm)
            pnpm install --frozen-lockfile
            ;;
          *)
            echo "Unsupported package manager: ${{ inputs.package-manager }}"
            exit 1
            ;;
        esac

    - name: Check for Nx updates
      id: check-update
      shell: bash
      working-directory: ${{ inputs.working-directory }}
      run: |
        echo "Using nx-version: ${{ inputs.nx-version }}"
        echo "Package to check: ${{ inputs.nx-package }}"

        # Show available dist-tags for debugging
        echo "Available dist-tags:"
        npm view ${{ inputs.nx-package }} dist-tags --json

        case "${{ inputs.package-manager }}" in
          npm)
            CURRENT_VERSION=$(npm list ${{ inputs.nx-package }} --depth=0 --json 2>/dev/null | jq -r '.dependencies["${{ inputs.nx-package }}"].version // empty')
            LATEST_VERSION=$(npm view ${{ inputs.nx-package }}@${{ inputs.nx-version }} version)
            ;;
          yarn)
            # Get current version using yarn list with pattern
            CURRENT_VERSION=$(yarn list --pattern "${{ inputs.nx-package }}" --depth=0 2>/dev/null | grep -E "^[^@]*@[0-9]" | sed 's/.*@//' | head -1)

            # Get latest version using yarn info
            echo "Getting latest version with: yarn info ${{ inputs.nx-package }}@${{ inputs.nx-version }} --json"
            YARN_INFO_JSON=$(yarn info ${{ inputs.nx-package }}@${{ inputs.nx-version }} --json 2>/dev/null)
            echo "Raw yarn info output: '${YARN_INFO_JSON}'"

            # Extract version from JSON using jq
            if command -v jq >/dev/null 2>&1; then
              # Try to get version from dist-tags first (for latest, next, etc.), then fallback to direct version field
              LATEST_VERSION=$(echo "$YARN_INFO_JSON" | jq -r '.data."dist-tags"."${{ inputs.nx-version }}" // .data.version // empty' 2>/dev/null)
            else
              # Fallback without jq - extract version from JSON manually
              # First try dist-tags, then fallback to direct version
              LATEST_VERSION=$(echo "$YARN_INFO_JSON" | grep -o '"${{ inputs.nx-version }}":"[^"]*"' | sed 's/"${{ inputs.nx-version }}":"\([^"]*\)"/\1/' | head -1)
              if [[ -z "$LATEST_VERSION" ]]; then
                LATEST_VERSION=$(echo "$YARN_INFO_JSON" | grep -o '"version":"[^"]*"' | sed 's/"version":"\([^"]*\)"/\1/' | head -1)
              fi
            fi

            echo "Extracted latest version: '${LATEST_VERSION}'"

            # If still empty, try simpler approach
            if [[ -z "$LATEST_VERSION" ]]; then
              echo "Fallback: trying yarn info ${{ inputs.nx-package }}@${{ inputs.nx-version }} version"
              LATEST_VERSION=$(yarn info ${{ inputs.nx-package }}@${{ inputs.nx-version }} version 2>/dev/null | tail -1 | grep -E '^[0-9]+\.[0-9]+\.[0-9]+')
              echo "Fallback version: '${LATEST_VERSION}'"
            fi
            ;;
          pnpm)
            CURRENT_VERSION=$(pnpm list ${{ inputs.nx-package }} --depth=0 --json 2>/dev/null | jq -r '.[0].dependencies["${{ inputs.nx-package }}"].version // empty')
            # pnpm view with dist-tags should return the actual version number
            LATEST_VERSION=$(pnpm view ${{ inputs.nx-package }}@${{ inputs.nx-version }} version)
            ;;
        esac

        # Validate that LATEST_VERSION is a proper version number (supports pre-release versions)
        if [[ ! "$LATEST_VERSION" =~ ^[0-9]+\.[0-9]+\.[0-9]+.*$ ]]; then
          echo "⚠️ Warning: Invalid version detected: '$LATEST_VERSION'"
          echo "Setting LATEST_VERSION to CURRENT_VERSION to avoid issues"
          LATEST_VERSION="$CURRENT_VERSION"
        fi

        echo "Final version resolution:"
        echo "  Current: $CURRENT_VERSION"
        echo "  Latest:  $LATEST_VERSION"

        if [[ "$CURRENT_VERSION" != "$LATEST_VERSION" && -n "$LATEST_VERSION" && -n "$CURRENT_VERSION" ]]; then
          echo "Current version: $CURRENT_VERSION"
          echo "Latest version: $LATEST_VERSION"
          echo "updated=true" >> $GITHUB_OUTPUT
          echo "current-version=$CURRENT_VERSION" >> $GITHUB_OUTPUT
          echo "target-version=$LATEST_VERSION" >> $GITHUB_OUTPUT
        else
          echo "Already up to date: $CURRENT_VERSION"
          echo "updated=false" >> $GITHUB_OUTPUT
          echo "current-version=$CURRENT_VERSION" >> $GITHUB_OUTPUT
          echo "target-version=$CURRENT_VERSION" >> $GITHUB_OUTPUT
        fi

    - name: Update Nx
      if: steps.check-update.outputs.updated == 'true'
      shell: bash
      working-directory: ${{ inputs.working-directory }}
      run: |
        echo "Updating Nx from ${{ steps.check-update.outputs.current-version }} to ${{ steps.check-update.outputs.target-version }}"
        npx nx migrate ${{ inputs.nx-version }}

    - name: Install dependencies after migration
      if: steps.check-update.outputs.updated == 'true'
      shell: bash
      working-directory: ${{ inputs.working-directory }}
      run: |
        case "${{ inputs.package-manager }}" in
          npm)
            npm install
            ;;
          yarn)
            yarn install
            ;;
          pnpm)
            pnpm install --no-frozen-lockfile
            ;;
        esac

    - name: Check for migrations
      if: steps.check-update.outputs.updated == 'true'
      id: check-migrations
      shell: bash
      working-directory: ${{ inputs.working-directory }}
      run: |
        if [[ -f migrations.json ]]; then
          echo "✅ Found migrations.json"
          echo "has-migrations=true" >> $GITHUB_OUTPUT

          # Check if migrations.json has actual migrations
          MIGRATION_COUNT=$(cat migrations.json | jq '.migrations | length // 0' 2>/dev/null || echo "0")
          echo "📋 Number of migrations found: $MIGRATION_COUNT"

          if [[ "$MIGRATION_COUNT" -gt 0 ]]; then
            echo "📝 Migrations to run:"
            cat migrations.json | jq '.migrations // {}' 2>/dev/null || echo "Could not parse migration details"
          else
            echo "ℹ️ migrations.json exists but contains no migrations"
          fi
        else
          echo "ℹ️ No migrations.json found - no migrations needed"
          echo "has-migrations=false" >> $GITHUB_OUTPUT
        fi

    - name: Run migrations
      if: steps.check-migrations.outputs.has-migrations == 'true'
      shell: bash
      working-directory: ${{ inputs.working-directory }}
      run: |
        echo "🚀 Running Nx migrations..."

        # Run migrations with error handling
        if npx nx migrate --run-migrations; then
          echo "✅ Migrations completed successfully"
        else
          echo "❌ Migration failed"
          echo "📋 migrations.json content:"
          cat migrations.json || echo "Could not read migrations.json"
          exit 1
        fi

    - name: Setup Git
      if: steps.check-update.outputs.updated == 'true'
      shell: bash
      run: |
        git config user.name "nx-migrate-bot"
        git config user.email "nx-migrate-bot@users.noreply.github.com"

    - name: Commit changes
      if: steps.check-update.outputs.updated == 'true'
      shell: bash
      working-directory: ${{ inputs.working-directory }}
      run: |
        LATEST_VERSION="${{ steps.check-update.outputs.target-version }}"
        git add .
        if [[ $(git status --porcelain) ]]; then
          git commit -m "${{ inputs.commit-message-prefix }}: update nx to version ${LATEST_VERSION}" \
                     -m "Automated update by nx-migrate action" \
                     -m "Updated from ${{ steps.check-update.outputs.current-version }} to ${LATEST_VERSION}"
          echo "Changes committed"
        else
          echo "No changes to commit"
        fi

    - name: Handle migrations.json after success
      if: steps.check-migrations.outputs.has-migrations == 'true'
      shell: bash
      working-directory: ${{ inputs.working-directory }}
      run: |
        if [[ -f migrations.json ]]; then
          if [[ "${{ inputs.push-migrations-json }}" == "yes" ]]; then
            echo "📝 Pushing migrations.json to repository for audit trail"
            git add migrations.json
            git commit -m "${{ inputs.commit-message-prefix }}: add migrations.json for audit trail"
            echo "✅ migrations.json committed to repository"
          else
            echo "🧹 Removing migrations.json after successful migration"
            rm -f migrations.json
            echo "✅ migrations.json cleaned up locally"
          fi
        else
          echo "ℹ️ No migrations.json to handle"
        fi

    - name: Create PR
      id: create-pr
      if: steps.check-update.outputs.updated == 'true'
      continue-on-error: true
      shell: bash
      working-directory: ${{ inputs.working-directory }}
      run: |
        LATEST_VERSION="${{ steps.check-update.outputs.target-version }}"
        DEV_MODE="${{ inputs.dev-mode }}"

        echo "Dev mode: ${DEV_MODE}"

        if [ "$DEV_MODE" = "true" ]; then
          echo "=== DEV MODE: Creating unique branch with matrix info ==="
          # Extract matrix values for branch naming
          MATRIX_JSON='${{ toJSON(matrix) }}'
          echo "Matrix JSON: ${MATRIX_JSON}"

          # Convert matrix to clean branch-safe string
          if [ "$MATRIX_JSON" != "null" ] && [ "$MATRIX_JSON" != "{}" ]; then
            MATRIX_VALUES=$(echo "$MATRIX_JSON" | jq -r 'to_entries | map("\(.key)-\(.value)") | join("-")' 2>/dev/null || echo "")
          else
            MATRIX_VALUES=""
          fi

          # Clean matrix values for branch name (remove invalid characters)
          CLEAN_MATRIX=$(echo "${MATRIX_VALUES}" | sed 's/[^a-zA-Z0-9-]/-/g' | sed 's/--*/-/g' | sed 's/^-\|-$//g')

          # Use job ID as fallback
          JOB_ID="${{ github.job }}"
          CLEAN_JOB_ID=$(echo "${JOB_ID}" | sed 's/[^a-zA-Z0-9-]/-/g' | sed 's/--*/-/g' | sed 's/^-\|-$//g')

          RUN_ID="${{ github.run_id }}"
          RUN_ATTEMPT="${{ github.run_attempt }}"

          # Build branch name with matrix values or job ID fallback
          if [ -n "$CLEAN_MATRIX" ]; then
            BRANCH="nx-migrate-${LATEST_VERSION}-${CLEAN_MATRIX}-${RUN_ID}-${RUN_ATTEMPT}"
          else
            BRANCH="nx-migrate-${LATEST_VERSION}-${CLEAN_JOB_ID}-${RUN_ID}-${RUN_ATTEMPT}"
          fi
        else
          echo "=== PROD MODE: Using simple branch naming ==="
          BRANCH="nx-migrate-${LATEST_VERSION}"

          # Check if branch already exists remotely
          echo "Checking if branch ${BRANCH} already exists..."
          if git ls-remote --exit-code --heads origin ${BRANCH} >/dev/null 2>&1; then
            echo "✅ Branch ${BRANCH} already exists. Skipping migration as it's likely already handled."
            echo "updated=false" >> $GITHUB_OUTPUT
            echo "current-version=${{ steps.check-update.outputs.current-version }}" >> $GITHUB_OUTPUT
            echo "latest-version=${LATEST_VERSION}" >> $GITHUB_OUTPUT
            echo "skip-reason=branch-exists" >> $GITHUB_OUTPUT
            exit 0
          fi
          echo "Branch ${BRANCH} does not exist, proceeding with migration."
        fi

        echo "=== PR Creation Debug Info ==="
        echo "Dev mode: ${DEV_MODE}"
        echo "Latest version: ${LATEST_VERSION}"
        if [ "$DEV_MODE" = "true" ]; then
          echo "Matrix JSON: ${MATRIX_JSON}"
          echo "Matrix values: ${MATRIX_VALUES}"
          echo "Clean matrix: ${CLEAN_MATRIX}"
          echo "Raw Job ID: ${JOB_ID}"
          echo "Clean Job ID: ${CLEAN_JOB_ID}"
          echo "Run ID: ${RUN_ID}"
          echo "Run attempt: ${RUN_ATTEMPT}"
        fi
        echo "Branch name: ${BRANCH}"
        echo "Working directory: $(pwd)"
        echo "Git status: $(git status --short)"

        # Set PR reason for always creating PRs
        PR_REASON="Ready for review and CI validation"
        STATUS_EMOJI="🔍"

        echo "Creating PR with branch: ${BRANCH}"

        # Check if branch already exists locally or remotely
        if git show-ref --verify --quiet refs/heads/${BRANCH}; then
          echo "Branch ${BRANCH} exists locally, deleting..."
          git branch -D ${BRANCH} 2>/dev/null || true
        fi

        if git ls-remote --exit-code --heads origin ${BRANCH} >/dev/null 2>&1; then
          echo "Branch ${BRANCH} exists remotely, deleting..."
          git push origin --delete ${BRANCH} 2>/dev/null || true
        fi

        echo "Creating new branch: ${BRANCH}"
        git checkout -b ${BRANCH}

        echo "Pushing branch to origin..."
        if ! git push --set-upstream origin ${BRANCH}; then
          echo "❌ Failed to push branch ${BRANCH}"
          echo "Git status: $(git status --porcelain)"
          echo "Git remote: $(git remote -v)"
          echo "Git branch: $(git branch -a)"
          exit 1
        fi
        echo "✅ Branch pushed successfully"

        # Convert labels to space-separated format for gh cli
        LABELS=$(echo "${{ inputs.pr-labels }}" | tr ',' ' ')

        # Create PR title and body - handle dev/prod mode
        if [ "$DEV_MODE" = "true" ]; then
          # Dev mode: include matrix info for identification
          if [ -n "$CLEAN_MATRIX" ]; then
            PR_TITLE="${{ inputs.commit-message-prefix }}: update nx to version ${LATEST_VERSION} (${CLEAN_MATRIX})"
          else
            PR_TITLE="${{ inputs.commit-message-prefix }}: update nx to version ${LATEST_VERSION} (${CLEAN_JOB_ID})"
          fi
        else
          # Prod mode: simple title
          PR_TITLE="${{ inputs.commit-message-prefix }}: update nx to version ${LATEST_VERSION}"
        fi

        PR_BODY="## 🚀 Nx Migrate Update

        **Version Update:** \`${{ steps.check-update.outputs.current-version }}\` → \`${LATEST_VERSION}\`

        **Status:** ${STATUS_EMOJI} ${PR_REASON}

        ### Changes Made:
        - Updated Nx workspace to version ${LATEST_VERSION}
        - Ran automated migrations: ${{ steps.check-migrations.outputs.has-migrations == 'true' && '✅ Yes' || '➖ Nx didn''t create any migrations for this version update' }}
        - Repository CI validation: Will be handled by your existing CI/CD workflows

        ### Configuration:
        - **Matrix:** ${CLEAN_MATRIX:-${CLEAN_JOB_ID}}
        - **Package Manager:** ${{ inputs.package-manager }}
        - **Working Directory:** ${{ inputs.working-directory }}
        - **Repository CI:** Will validate changes via standard CI/CD pipeline

        ---
        *This PR was created automatically by the [nx-migrate action](https://github.com/gridatek/nx-migrate-action)*"

        # Create PR
        echo "=== Creating PR ==="
        echo "Title: ${PR_TITLE}"
        echo "Base branch: ${{ inputs.target-branch }}"
        echo "Head branch: ${BRANCH}"
        echo "Labels: ${LABELS}"
        echo "GitHub token present: $([[ -n "$GITHUB_TOKEN" ]] && echo 'Yes' || echo 'No')"
        echo "PR body length: ${#PR_BODY} characters"

        # Check if this is an org repo and what permissions we have
        echo "Repository info:"
        gh repo view --json owner,name,isOrganization || echo "Failed to get repo info"
        echo "Token permissions:"
        gh auth status || echo "Auth check failed"

        # Create PR with explicit error handling
        echo "Executing: gh pr create..."
        set +e  # Don't exit on error

        # Try to create PR with labels first
        PR_URL=$(gh pr create \
          --title "${PR_TITLE}" \
          --body "${PR_BODY}" \
          --label "${LABELS}" \
          --base ${{ github.ref_name }} \
          --head ${BRANCH} 2>&1)
        PR_EXIT_CODE=$?

        # If PR creation failed due to labels, try without labels
        if [[ $PR_EXIT_CODE -ne 0 && "$PR_URL" == *"not found"* ]]; then
          echo "⚠️ Label creation failed, retrying without labels..."

          # Create missing labels if enabled
          if [[ "${{ inputs.create-missing-labels }}" == "true" ]]; then
            echo "🏷️ Creating missing labels..."
            IFS=' ' read -ra LABEL_ARRAY <<< "${LABELS}"
            for label in "${LABEL_ARRAY[@]}"; do
              case "$label" in
                "dependencies")
                  gh label create "$label" --description "Pull requests that update dependencies" --color "0366d6" 2>/dev/null && echo "  ✅ Created label: $label" || echo "  ℹ️ Label already exists: $label"
                  ;;
                "nx-migration")
                  gh label create "$label" --description "Automated Nx workspace migrations" --color "7057ff" 2>/dev/null && echo "  ✅ Created label: $label" || echo "  ℹ️ Label already exists: $label"
                  ;;
                "automated")
                  gh label create "$label" --description "Automated changes by GitHub Actions" --color "ededed" 2>/dev/null && echo "  ✅ Created label: $label" || echo "  ℹ️ Label already exists: $label"
                  ;;
                *)
                  gh label create "$label" --description "Auto-created by nx-migrate action" --color "f9d0c4" 2>/dev/null && echo "  ✅ Created label: $label" || echo "  ℹ️ Label already exists: $label"
                  ;;
              esac
            done
          fi

          # Retry PR creation
          PR_URL=$(gh pr create \
            --title "${PR_TITLE}" \
            --body "${PR_BODY}" \
            --label "${LABELS}" \
            --base ${{ github.ref_name }} \
            --head ${BRANCH} 2>&1)
          PR_EXIT_CODE=$?

          # If still failing, create without labels
          if [[ $PR_EXIT_CODE -ne 0 ]]; then
            echo "⚠️ Still failing with labels, creating PR without labels..."
            PR_URL=$(gh pr create \
              --title "${PR_TITLE}" \
              --body "${PR_BODY}" \
              --base ${{ github.ref_name }} \
              --head ${BRANCH} 2>&1)
            PR_EXIT_CODE=$?

            # Try to add labels individually after PR creation
            if [[ $PR_EXIT_CODE -eq 0 ]]; then
              echo "✅ PR created without labels, attempting to add labels individually..."
              IFS=' ' read -ra LABEL_ARRAY <<< "${LABELS}"
              for label in "${LABEL_ARRAY[@]}"; do
                gh pr edit ${BRANCH} --add-label "$label" 2>/dev/null && echo "  ✅ Added label: $label" || echo "  ⚠️ Failed to add label: $label"
              done
            fi
          fi
        fi

        set -e  # Re-enable exit on error

        echo "PR creation exit code: ${PR_EXIT_CODE}"
        echo "PR creation output: ${PR_URL}"

        if [[ $PR_EXIT_CODE -eq 0 && -n "$PR_URL" ]]; then
          echo "pr-url=$PR_URL" >> $GITHUB_OUTPUT
          echo "✅ PR created successfully: $PR_URL"
        else
          echo "❌ PR creation failed"
          echo "Exit code: ${PR_EXIT_CODE}"
          echo "Output: ${PR_URL}"

          # Try to get existing PR URL as fallback
          echo "Checking for existing PR..."
          EXISTING_PR=$(gh pr view ${BRANCH} --json url --jq '.url' 2>/dev/null || echo "")
          if [[ -n "$EXISTING_PR" ]]; then
            echo "pr-url=$EXISTING_PR" >> $GITHUB_OUTPUT
            echo "ℹ️ PR already exists: $EXISTING_PR"
            echo "✅ Using existing PR instead of creating new one"
          else
            echo "No existing PR found"
            # Additional debugging
            echo "=== Debugging Info ==="
            echo "Current branch: $(git branch --show-current)"
            echo "Remote branches: $(git branch -r | head -5)"
            echo "GitHub CLI auth status:"
            gh auth status || echo "GitHub CLI auth failed"
            echo "Repository info:"
            gh repo view --json name,owner,defaultBranch || echo "Failed to get repo info"

            # Exit with error if we can't create or find a PR
            echo "❌ Failed to create PR and no existing PR found"
            exit 1
          fi
        fi
