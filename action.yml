name: 'Nx Migration'
description: 'Automatically migrate Nx workspace to the latest version with validation and smart PR creation'
author: 'Khalil LAGRIDA'

branding:
  icon: 'arrow-up'
  color: 'blue'

inputs:
  github-token:
    description: 'GitHub token for creating PRs and pushing changes'
    required: true
    default: '${{ github.token }}'

  nx-package:
    description: 'The Nx package to check for updates'
    required: false
    default: 'nx'

  node-version:
    description: 'Node.js version to use'
    required: false
    default: '22'

  package-manager:
    description: 'Package manager to use (npm, yarn, pnpm)'
    required: false
    default: 'npm'

  validation-commands:
    description: 'Commands to run for validation (comma-separated)'
    required: false
    default: 'build'

  validation-scope:
    description: 'Scope for validation commands (all, affected)'
    required: false
    default: 'affected'

  merge-strategy:
    description: 'Merge strategy after validation (auto-merge, always-pr)'
    required: false
    default: 'auto-merge'

  pr-labels:
    description: 'Labels to add to PRs (comma-separated)'
    required: false
    default: 'nx-migrate-action'

  commit-message-prefix:
    description: 'Prefix for commit messages'
    required: false
    default: 'build'

  target-branch:
    description: 'Target branch for merging changes'
    required: false
    default: 'main'

  working-directory:
    description: 'Working directory for the action'
    required: false
    default: '.'

  push-migrations-json:
    description: 'Push migrations.json to repository after successful migration'
    required: false
    default: 'false'

  nx-version-tag:
    description: 'Version tag to use when fetching updates (e.g., latest, beta, canary, next - see npm dist-tags)'
    required: false
    default: 'latest'

  create-missing-labels:
    description: 'Create missing labels in the repository'
    required: false
    default: 'true'

outputs:
  updated:
    description: 'Whether Nx was updated'
    value: ${{ steps.check-update.outputs.updated }}

  current-version:
    description: 'Current Nx version before update'
    value: ${{ steps.check-update.outputs.current-version }}

  latest-version:
    description: 'Latest Nx version'
    value: ${{ steps.check-update.outputs.latest-version }}

  has-migrations:
    description: 'Whether migrations were found'
    value: ${{ steps.check-migrations.outputs.has-migrations }}

  validation-result:
    description: 'Result of validation tests'
    value: ${{ steps.validation.outputs.result }}

  pr-url:
    description: 'URL of created PR (if any)'
    value: ${{ steps.create-pr.outputs.pr-url }}

runs:
  using: 'composite'
  steps:
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ inputs.node-version }}
        cache: ${{ inputs.package-manager }}

    - name: Install dependencies
      shell: bash
      working-directory: ${{ inputs.working-directory }}
      run: |
        case "${{ inputs.package-manager }}" in
          npm)
            npm ci
            ;;
          yarn)
            yarn install --frozen-lockfile
            ;;
          pnpm)
            pnpm install --frozen-lockfile
            ;;
          *)
            echo "Unsupported package manager: ${{ inputs.package-manager }}"
            exit 1
            ;;
        esac

    - name: Check for Nx updates
      id: check-update
      shell: bash
      working-directory: ${{ inputs.working-directory }}
      run: |
        echo "Using nx-version-tag: ${{ inputs.nx-version-tag }}"
        echo "Package to check: ${{ inputs.nx-package }}"

        # Show available dist-tags for debugging
        echo "Available dist-tags:"
        npm view ${{ inputs.nx-package }} dist-tags --json

        case "${{ inputs.package-manager }}" in
          npm)
            CURRENT_VERSION=$(npm list ${{ inputs.nx-package }} --depth=0 --json 2>/dev/null | jq -r '.dependencies["${{ inputs.nx-package }}"].version // empty')
            LATEST_VERSION=$(npm view ${{ inputs.nx-package }}@${{ inputs.nx-version-tag }} version)
            ;;
          yarn)
            CURRENT_VERSION=$(yarn list ${{ inputs.nx-package }} --depth=0 --json 2>/dev/null | jq -r '.data.trees[0].name // empty' | sed 's/.*@//')
            # Debug: show what we're trying to fetch
            echo "Fetching yarn info for: ${{ inputs.nx-package }}@${{ inputs.nx-version-tag }}"
            # Get the actual version number, not the tag
            YARN_INFO_OUTPUT=$(yarn info ${{ inputs.nx-package }}@${{ inputs.nx-version-tag }} --json 2>/dev/null)
            echo "Yarn info output: $YARN_INFO_OUTPUT"
            LATEST_VERSION=$(echo "$YARN_INFO_OUTPUT" | jq -r '.data.version // empty' 2>/dev/null)
            echo "Extracted version: $LATEST_VERSION"
            if [[ -z "$LATEST_VERSION" || "$LATEST_VERSION" == "null" || "$LATEST_VERSION" == "empty" ]]; then
              # Fallback: extract version from yarn info output without --json
              echo "jq failed, trying fallback method"
              LATEST_VERSION=$(yarn info ${{ inputs.nx-package }}@${{ inputs.nx-version-tag }} version 2>/dev/null | tail -1)
              echo "Fallback version: $LATEST_VERSION"
            fi
            ;;
          pnpm)
            CURRENT_VERSION=$(pnpm list ${{ inputs.nx-package }} --depth=0 --json 2>/dev/null | jq -r '.[0].dependencies["${{ inputs.nx-package }}"].version // empty')
            LATEST_VERSION=$(pnpm view ${{ inputs.nx-package }}@${{ inputs.nx-version-tag }} version)
            ;;
        esac

        if [[ "$CURRENT_VERSION" != "$LATEST_VERSION" && -n "$LATEST_VERSION" && -n "$CURRENT_VERSION" ]]; then
          echo "Current version: $CURRENT_VERSION"
          echo "Latest version: $LATEST_VERSION"
          echo "updated=true" >> $GITHUB_OUTPUT
          echo "current-version=$CURRENT_VERSION" >> $GITHUB_OUTPUT
          echo "latest-version=$LATEST_VERSION" >> $GITHUB_OUTPUT
        else
          echo "Already up to date: $CURRENT_VERSION"
          echo "updated=false" >> $GITHUB_OUTPUT
          echo "current-version=$CURRENT_VERSION" >> $GITHUB_OUTPUT
          echo "latest-version=$CURRENT_VERSION" >> $GITHUB_OUTPUT
        fi

    - name: Update Nx
      if: steps.check-update.outputs.updated == 'true'
      shell: bash
      working-directory: ${{ inputs.working-directory }}
      run: |
        echo "Updating Nx from ${{ steps.check-update.outputs.current-version }} to ${{ steps.check-update.outputs.latest-version }}"
        npx nx migrate ${{ inputs.nx-version-tag }}

    - name: Install dependencies after migration
      if: steps.check-update.outputs.updated == 'true'
      shell: bash
      working-directory: ${{ inputs.working-directory }}
      run: |
        case "${{ inputs.package-manager }}" in
          npm)
            npm install
            ;;
          yarn)
            yarn install
            ;;
          pnpm)
            pnpm install --no-frozen-lockfile
            ;;
        esac

    - name: Check for migrations
      if: steps.check-update.outputs.updated == 'true'
      id: check-migrations
      shell: bash
      working-directory: ${{ inputs.working-directory }}
      run: |
        if [[ -f migrations.json ]]; then
          echo "‚úÖ Found migrations.json"
          echo "has-migrations=true" >> $GITHUB_OUTPUT

          # Check if migrations.json has actual migrations
          MIGRATION_COUNT=$(cat migrations.json | jq '.migrations | length // 0' 2>/dev/null || echo "0")
          echo "üìã Number of migrations found: $MIGRATION_COUNT"

          if [[ "$MIGRATION_COUNT" -gt 0 ]]; then
            echo "üìù Migrations to run:"
            cat migrations.json | jq '.migrations // {}' 2>/dev/null || echo "Could not parse migration details"
          else
            echo "‚ÑπÔ∏è migrations.json exists but contains no migrations"
          fi
        else
          echo "‚ÑπÔ∏è No migrations.json found - no migrations needed"
          echo "has-migrations=false" >> $GITHUB_OUTPUT
        fi

    - name: Run migrations
      if: steps.check-migrations.outputs.has-migrations == 'true'
      shell: bash
      working-directory: ${{ inputs.working-directory }}
      run: |
        echo "üöÄ Running Nx migrations..."

        # Run migrations with error handling
        if npx nx migrate --run-migrations; then
          echo "‚úÖ Migrations completed successfully"
        else
          echo "‚ùå Migration failed"
          echo "üìã migrations.json content:"
          cat migrations.json || echo "Could not read migrations.json"
          exit 1
        fi

    - name: Setup Git
      if: steps.check-update.outputs.updated == 'true'
      shell: bash
      run: |
        git config user.name "nx-migrate-bot"
        git config user.email "nx-migrate-bot@users.noreply.github.com"

    - name: Commit changes
      if: steps.check-update.outputs.updated == 'true'
      shell: bash
      working-directory: ${{ inputs.working-directory }}
      run: |
        LATEST_VERSION="${{ steps.check-update.outputs.latest-version }}"
        git add .
        if [[ $(git status --porcelain) ]]; then
          git commit -m "${{ inputs.commit-message-prefix }}: update nx to version ${LATEST_VERSION}" \
                     -m "Automated update by nx-migrate action" \
                     -m "Updated from ${{ steps.check-update.outputs.current-version }} to ${LATEST_VERSION}"
          echo "Changes committed"
        else
          echo "No changes to commit"
        fi

    - name: Handle migrations.json after success
      if: steps.check-migrations.outputs.has-migrations == 'true'
      shell: bash
      working-directory: ${{ inputs.working-directory }}
      run: |
        if [[ -f migrations.json ]]; then
          if [[ "${{ inputs.push-migrations-json }}" == "yes" ]]; then
            echo "üìù Pushing migrations.json to repository for audit trail"
            git add migrations.json
            git commit -m "${{ inputs.commit-message-prefix }}: add migrations.json for audit trail"
            echo "‚úÖ migrations.json committed to repository"
          else
            echo "üßπ Removing migrations.json after successful migration"
            rm -f migrations.json
            echo "‚úÖ migrations.json cleaned up locally"
          fi
        else
          echo "‚ÑπÔ∏è No migrations.json to handle"
        fi

    - name: Run validation
      id: validation
      if: steps.check-update.outputs.updated == 'true'
      continue-on-error: true
      shell: bash
      working-directory: ${{ inputs.working-directory }}
      run: |
        echo "Running validation commands..."
        
        # Convert comma-separated commands to array
        IFS=',' read -ra COMMANDS <<< "${{ inputs.validation-commands }}"
        
        VALIDATION_SUCCESS=true
        
        for cmd in "${COMMANDS[@]}"; do
          cmd=$(echo "$cmd" | xargs)  # trim whitespace
          echo "Running: nx run-many --target=$cmd --${{ inputs.validation-scope }}"
        
          if ! npx nx run-many --target="$cmd" --${{ inputs.validation-scope }} --skip-nx-cache; then
            echo "‚ùå Command failed: $cmd"
            VALIDATION_SUCCESS=false
          else
            echo "‚úÖ Command succeeded: $cmd"
          fi
        done
        
        if [[ "$VALIDATION_SUCCESS" == "true" ]]; then
          echo "result=success" >> $GITHUB_OUTPUT
          echo "‚úÖ All validation commands passed"
        else
          echo "result=failure" >> $GITHUB_OUTPUT
          echo "‚ùå Some validation commands failed"
          exit 1
        fi
      env:
        NX_VERBOSE_LOGGING: 'true'
        GITHUB_ACTIONS: 'true'

    - name: Push to main branch
      if: |
        steps.check-update.outputs.updated == 'true' &&
        inputs.merge-strategy == 'auto-merge' &&
        steps.validation.outputs.result == 'success'
      shell: bash
      run: |
        echo "Validation passed, pushing directly to ${{ inputs.target-branch }}"
        git push origin HEAD:${{ inputs.target-branch }}

    - name: Create PR
      id: create-pr
      if: |
        steps.check-update.outputs.updated == 'true' &&
        (
          inputs.merge-strategy == 'always-pr' ||
          (inputs.merge-strategy == 'auto-merge' && steps.validation.outputs.result != 'success')
        )
      continue-on-error: true
      shell: bash
      working-directory: ${{ inputs.working-directory }}
      env:
        GITHUB_TOKEN: ${{ inputs.github-token }}
      run: |
        LATEST_VERSION="${{ steps.check-update.outputs.latest-version }}"
        BRANCH="nx-migrate-${LATEST_VERSION}-${{ github.run_id }}-${{ github.run_attempt }}"

        echo "=== PR Creation Debug Info ==="
        echo "Latest version: ${LATEST_VERSION}"
        echo "Run ID: ${{ github.run_id }}"
        echo "Run attempt: ${{ github.run_attempt }}"
        echo "Branch name: ${BRANCH}"
        echo "Working directory: $(pwd)"
        echo "Git status: $(git status --short)"
        
        # Determine PR reason
        if [[ "${{ inputs.merge-strategy }}" == "always-pr" ]]; then
          PR_REASON="Manual review requested (always-pr strategy)"
          STATUS_EMOJI="üîç"
        else
          PR_REASON="Validation tests failed"
          STATUS_EMOJI="‚ö†Ô∏è"
        fi
        
        echo "Creating PR with branch: ${BRANCH}"
        git checkout -b ${BRANCH}

        # Try to push branch, handle conflicts gracefully
        if ! git push --set-upstream origin ${BRANCH}; then
          echo "Failed to push branch ${BRANCH}, trying with force..."
          # Try to delete and recreate if branch exists
          git push origin --delete ${BRANCH} 2>/dev/null || true
          git push --set-upstream origin ${BRANCH}
        fi
        
        # Convert labels to space-separated format for gh cli
        LABELS=$(echo "${{ inputs.pr-labels }}" | tr ',' ' ')
        
        # Create PR body
        PR_BODY="## üöÄ Nx Migration Update

        **Version Update:** \`${{ steps.check-update.outputs.current-version }}\` ‚Üí \`${LATEST_VERSION}\`

        **Status:** ${STATUS_EMOJI} ${PR_REASON}

        ### Changes Made:
        - Updated Nx workspace to version ${LATEST_VERSION}
        - Ran automated migrations: ${{ steps.check-migrations.outputs.has-migrations == 'true' && '‚úÖ Yes' || '‚ùå No' }}
        - Validation result: ${{ steps.validation.outputs.result || 'skipped' }}

        ### Package Manager: ${{ inputs.package-manager }}
        ### Node Version: ${{ inputs.node-version }}

        ---
        *This PR was created automatically by the [nx-migrate action](https://github.com/gridatek/nx-migrate-action)*"

        # Create PR
        echo "=== Creating PR ==="
        echo "Title: ${{ inputs.commit-message-prefix }}: update nx to version ${LATEST_VERSION}"
        echo "Base branch: ${{ inputs.target-branch }}"
        echo "Head branch: ${BRANCH}"
        echo "Labels: ${LABELS}"
        echo "GitHub token present: $([[ -n "$GITHUB_TOKEN" ]] && echo 'Yes' || echo 'No')"
        echo "PR body length: ${#PR_BODY} characters"

        # Check if this is an org repo and what permissions we have
        echo "Repository info:"
        gh repo view --json owner,name,isOrganization || echo "Failed to get repo info"
        echo "Token permissions:"
        gh auth status || echo "Auth check failed"

        # Create PR with explicit error handling
        echo "Executing: gh pr create..."
        set +e  # Don't exit on error

        # Try to create PR with labels first
        PR_URL=$(gh pr create \
          --title "${{ inputs.commit-message-prefix }}: update nx to version ${LATEST_VERSION}" \
          --body "${PR_BODY}" \
          --label "${LABELS}" \
          --base ${{ inputs.target-branch }} \
          --head ${BRANCH} 2>&1)
        PR_EXIT_CODE=$?

        # If PR creation failed due to labels, try without labels
        if [[ $PR_EXIT_CODE -ne 0 && "$PR_URL" == *"not found"* ]]; then
          echo "‚ö†Ô∏è Label creation failed, retrying without labels..."

          # Create missing labels if enabled
          if [[ "${{ inputs.create-missing-labels }}" == "true" ]]; then
            echo "üè∑Ô∏è Creating missing labels..."
            IFS=' ' read -ra LABEL_ARRAY <<< "${LABELS}"
            for label in "${LABEL_ARRAY[@]}"; do
              case "$label" in
                "dependencies")
                  gh label create "$label" --description "Pull requests that update dependencies" --color "0366d6" 2>/dev/null && echo "  ‚úÖ Created label: $label" || echo "  ‚ÑπÔ∏è Label already exists: $label"
                  ;;
                "nx-migration")
                  gh label create "$label" --description "Automated Nx workspace migrations" --color "7057ff" 2>/dev/null && echo "  ‚úÖ Created label: $label" || echo "  ‚ÑπÔ∏è Label already exists: $label"
                  ;;
                "automated")
                  gh label create "$label" --description "Automated changes by GitHub Actions" --color "ededed" 2>/dev/null && echo "  ‚úÖ Created label: $label" || echo "  ‚ÑπÔ∏è Label already exists: $label"
                  ;;
                *)
                  gh label create "$label" --description "Auto-created by nx-migrate action" --color "f9d0c4" 2>/dev/null && echo "  ‚úÖ Created label: $label" || echo "  ‚ÑπÔ∏è Label already exists: $label"
                  ;;
              esac
            done
          fi

          # Retry PR creation
          PR_URL=$(gh pr create \
            --title "${{ inputs.commit-message-prefix }}: update nx to version ${LATEST_VERSION}" \
            --body "${PR_BODY}" \
            --label "${LABELS}" \
            --base ${{ inputs.target-branch }} \
            --head ${BRANCH} 2>&1)
          PR_EXIT_CODE=$?

          # If still failing, create without labels
          if [[ $PR_EXIT_CODE -ne 0 ]]; then
            echo "‚ö†Ô∏è Still failing with labels, creating PR without labels..."
            PR_URL=$(gh pr create \
              --title "${{ inputs.commit-message-prefix }}: update nx to version ${LATEST_VERSION}" \
              --body "${PR_BODY}" \
              --base ${{ inputs.target-branch }} \
              --head ${BRANCH} 2>&1)
            PR_EXIT_CODE=$?

            # Try to add labels individually after PR creation
            if [[ $PR_EXIT_CODE -eq 0 ]]; then
              echo "‚úÖ PR created without labels, attempting to add labels individually..."
              IFS=' ' read -ra LABEL_ARRAY <<< "${LABELS}"
              for label in "${LABEL_ARRAY[@]}"; do
                gh pr edit ${BRANCH} --add-label "$label" 2>/dev/null && echo "  ‚úÖ Added label: $label" || echo "  ‚ö†Ô∏è Failed to add label: $label"
              done
            fi
          fi
        fi

        set -e  # Re-enable exit on error

        echo "PR creation exit code: ${PR_EXIT_CODE}"
        echo "PR creation output: ${PR_URL}"

        if [[ $PR_EXIT_CODE -eq 0 && -n "$PR_URL" ]]; then
          echo "pr-url=$PR_URL" >> $GITHUB_OUTPUT
          echo "‚úÖ PR created successfully: $PR_URL"
        else
          echo "‚ùå PR creation failed"
          echo "Exit code: ${PR_EXIT_CODE}"
          echo "Output: ${PR_URL}"

          # Try to get existing PR URL as fallback
          echo "Checking for existing PR..."
          EXISTING_PR=$(gh pr view ${BRANCH} --json url --jq '.url' 2>/dev/null || echo "")
          if [[ -n "$EXISTING_PR" ]]; then
            echo "pr-url=$EXISTING_PR" >> $GITHUB_OUTPUT
            echo "‚ÑπÔ∏è PR already exists: $EXISTING_PR"
            echo "‚úÖ Using existing PR instead of creating new one"
          else
            echo "No existing PR found"
            # Additional debugging
            echo "=== Debugging Info ==="
            echo "Current branch: $(git branch --show-current)"
            echo "Remote branches: $(git branch -r | head -5)"
            echo "GitHub CLI auth status:"
            gh auth status || echo "GitHub CLI auth failed"
            echo "Repository info:"
            gh repo view --json name,owner,defaultBranch || echo "Failed to get repo info"

            # Exit with error if we can't create or find a PR
            echo "‚ùå Failed to create PR and no existing PR found"
            exit 1
          fi
        fi